---
title: "java重学一遍笔记"
tags: ""
---

# 类的继承

## 访问权限问题
### 关于继承中子类访问父类的私有域
在类的继承中，子类可以访问父类的所有公有方法和域，但对于父类的私有方法和域则不能访问。那么怎么在子类中给从父类继承来的私有域赋值呢？
- 在子类构造器的**第一句**添加 `super (paramList)`
- 如果子类构造器没有显示调用`super`，则会自动调用父类的默认（没有参数的）构造器。
- 但是如果父类中没有不带参数的构造器，在子类中又没有显示调用`super`，Java编译器就会报告错误

这里可以对比this的用途：
- 一是引用隐式参数，也就是当前对象
- 二是调用当前类的其他构造器

注意，调用构造器的语句`this(paramlist)`，`super(paramlist)`只能作为另一个构造器的第一条语句出现

## 子类的构造方法
构造方法是一个类独有的方法，父类的构造方法不会被子类继承。如果子类没有显式定义自己的构造方法，JVM当然会给子类分配一个默认的无参构造方法，但这个构造方法里面又没有显示调用父类的构造方法，则系统这时就会自动调用父类的无参构造方法。

## 那么子类从父类那里继承了什么？
子类从父类继承了所有的实例域和类域（静态域），所有的实例成员方法和类方法（静态方法），但是并没有继承父类的构造方法。

## 在创建一个子类对象的过程中都发生了什么事？

## 多态

1. 是谁的多态？
    - 成员变量是没有多态的，有多态的是成员函数

2. 可以将一个子类对象赋给一个超类变量，但是不能将一个超类的引用赋给子类变量。
   - 这也很好理解：当把一个子类对象赋给超类变量时，编译器会忽略超类原本没有的域和方法，但是如果时把一个超类对象赋给子类，这个超类对象缺少子类中增加的域和方法。

动态绑定是默认的处理方式，如果不希望一个方法具有这样的虚拟特征，可以将它标记为`final`


2. 一种会引发错误的情形：子类数组的引用可以转换成超类数组的引用

3. 成员变量没有多态

3. 实例化子类对象时会先实例化超类对象吗？

4. 多态中的this



### 向上转型和向下转型
### 向上转型：
多态本身就是向上转型过的过程
- 使用格式：`Father father = new Son();`
- 适用场景：当不需要面对子类类型时，通过提高扩展性，或者使用父类的功能就能完成相应的操作。

### 向下转型：
一个**已经向上转型**的子类对象可以使用强制类型转换的格式，将父类引用类型转为子类引用各类型
- 使用格式：`Son son = (Son)father;`
- 适用场景：当要使用子类特有功能时。



## 多继承
类似C++中的多继承功能，在Java中是通过接口`interface`实现的